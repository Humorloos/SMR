import os
from typing import List, TextIO, Tuple, Optional

from bs4 import Tag
from sqlite3 import IntegrityError

from anki import Collection
from main.consts import ADDON_PATH, USER_PATH
from main.dto.nodecontentdto import NodeContentDTO
from main.dto.smrnotedto import SmrNoteDto
from main.dto.smrtripledto import SmrTripleDto
from main.dto.xmindfiledto import XmindFileDto
from main.dto.xmindmediatoankifilesdto import XmindMediaToAnkiFilesDto
from main.dto.xmindnodedto import XmindNodeDto
from main.dto.xmindsheetdto import XmindSheetDto
from owlready2.namespace import World
from main.xmanager import XManager

FILE_NAME = 'smrworld.sqlite3'
SQL_FILE_NAME = 'smrworld.sql'
REFERENCE_FILE_NAME = 'reference.sql'
ANKI_COLLECTION_DB_NAME = "anki_collection"


def get_xmind_content_selection_clause(relation_name: str) -> str:
    """
    builds an sql select clause that returns title, image, and media in the correct format to be displayed in anki
    fields
    :param relation_name: the name of the relation in the smr world to get the content from
    :return: the select clause
    """
    return """
    ifnull({relation_name}.title, '') || IFNULL(' <img src="' || (
    SELECT anki_file_name FROM xmind_media_to_anki_files WHERE xmind_uri = {relation_name}.image) || '">', '') ||
                                      IFNULL(' [sound:' || (
                                          SELECT anki_file_name
                                          FROM xmind_media_to_anki_files
                                          WHERE xmind_uri = {relation_name}.link) || ']', '')
                                          """.format(relation_name=relation_name)


def get_xmind_hierarchy_recursive_cte_clause(edge_id: str):
    """
    gets a hierarchical recursive cte sql clause that can be used to access informations of a node's parents in a
    hierarchical manner.
    :param edge_id: the xmind id of the edge from where to start gathering parents' information
    :return: the cte clause
    """
    return """
WITH ancestor AS (
    SELECT parent_node_id,
           edge_id,
           child_node_id,
           0 level
    FROM smr_triples
    WHERE edge_id = '{edge_id}'
    UNION ALL
    SELECT t.parent_node_id,
           t.edge_id,
           t.child_node_id,
           a.level + 1
    FROM smr_triples t
             JOIN ancestor a
                  ON a.parent_node_id = t.child_node_id
)""".format(edge_id=edge_id)


class SmrWorld(World):
    """
    Class for managing all the data required by SMR. The smr world is an sqlite database containing the ontologies
    generated by owlready2 and all information needed by the SMR Addon to synchronize xmind files with the anki
    collection and manage the retrieval order.
    """

    def __init__(self):
        super().__init__()
        self.set_backend(filename=os.path.join(USER_PATH, FILE_NAME))
        self.graph.execute('PRAGMA foreign_keys = ON')
        self.save()

    def set_up(self) -> None:
        """
        Sets up SMR's database architecture. Use this method once to set up the database for the first time.
        """
        sql_file: TextIO = open(os.path.join(ADDON_PATH, SQL_FILE_NAME), 'r')
        sql_code: List[str] = sql_file.read().split(';')
        sql_file.close()
        for statement in sql_code:
            self.graph.execute(statement)
        self.save()

    def add_ontology_lives_in_deck(self, ontology_base_iri: str, deck_id: str) -> None:
        """
        Registers a deck for an imported ontology
        :param ontology_base_iri: base_iri of the imported ontology
        :param deck_id: the id of the deck from anki (number in form of a string)
        """
        c = self.graph.execute("SELECT c FROM ontologies WHERE iri = '{}'".format(ontology_base_iri)).fetchone()[0]
        self.graph.execute("INSERT INTO ontology_lives_in_deck VALUES (?, ?)", (int(deck_id), c))

    def add_xmind_files(self, entities: List[XmindFileDto]) -> None:
        """
        Adds an entry for an xmind file to the relation xmind_files
        :param entities: List of entries to be inserted into the xmind_files relation
        """
        self.graph.db.executemany("INSERT INTO main.xmind_files VALUES (?, ?, ?, ?)",
                                  (tuple(e) for e in entities))

    def add_xmind_sheets(self, entities: List[XmindSheetDto]) -> None:
        """
        Adds an entry for an xmind sheet to the relation xmind_sheets
        :param entities: List of entries to be inserted into the xmind_sheets relation
        """
        self.graph.db.executemany("INSERT INTO main.xmind_sheets VALUES (?, ?, ?)",
                                  (tuple(e) for e in entities))

    def add_xmind_nodes(self, entities: List[XmindNodeDto]) -> None:
        """
        Adds entries for xmind nodes to the relation xmind_nodes
        :param entities: List of entries for the xmind nodes relation
        """
        self.graph.db.executemany("INSERT INTO main.xmind_nodes VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                                  (tuple(e) for e in entities))

    def add_xmind_edges(self, entities: List[XmindNodeDto]) -> None:
        """
        Adds entries for xmind edges to the relation xmind_edges
        :param entities: List of entries for the xmind edges relation
        """
        self.graph.db.executemany("INSERT INTO main.xmind_edges VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                                  (tuple(e) for e in entities))

    def add_smr_triples(self, entities: List[SmrTripleDto]) -> None:
        """
        adds entries for triples of parent node, edge, and child node to the relation smr_triples
        :param entities: List of entries to add to the smr triples relation
        """
        self.graph.db.executemany("INSERT INTO main.smr_triples VALUES (?, ?, ?, ?)",
                                  (tuple(e) for e in entities))

    def update_smr_triples_card_ids(self, data: List[Tuple[int, int]], collection: Collection) -> None:
        """
        updates the card ids for all triples belonging to certain answers in smr notes
        :param data: List of tuples containing the note_id of the note the card belongs to and the order_number of
        the card with the card id to add to each triple
        :param collection: The collection that contains the cards whose ids to add
        """
        self.attach_anki_collection(collection)
        self.graph.db.executemany("""with card_triples(edge_id, child_node_id, card_id) as (
    select smr_triples.edge_id, child_node_id, cards.id
    from smr_triples
             join smr_notes using (edge_id)
             join cards on smr_notes.note_id = cards.nid
             join xmind_nodes on smr_triples.child_node_id = xmind_nodes.node_id
    where note_id = ?
      and order_number = ?
      and ord = order_number - 1)
update smr_triples
set card_id = (select card_id from card_triples)
where edge_id = (select edge_id from card_triples)
  and child_node_id = (select child_node_id from card_triples)""", data)
        self.detach_anki_collection(collection)

    def add_xmind_media_to_anki_files(self, entities: List[XmindMediaToAnkiFilesDto]) -> None:
        """
        adds entries linking xmind file uris to anki file names to the relation xmind_media_to_anki_files
        :param entities: List containing the media to file entries to add to the relation
        """
        self.graph.db.executemany("INSERT INTO main.xmind_media_to_anki_files VALUES (?, ?) ON CONFLICT DO NOTHING",
                                  (tuple(e) for e in entities))

    def add_smr_notes(self, entities: List[SmrNoteDto]):
        """
        adds entries linking xmind edges to anki notes and saving the creation time in last_modified
        :param entities: smr note entries to add to the relation
        """
        self.graph.db.executemany("INSERT INTO main.smr_notes VALUES (?, ?, ?)", (tuple(e) for e in entities))

    def get_smr_note_reference_data(self, edge_id: str) -> List[Tuple[str, str]]:
        """
        gets the data needed to generate the reference for an smr note from the smr world. The returned data
        consists of a List of tuples. In each tuple, the first value is the field content of a node and the second
        value is the field content of the edge following the node. The list contains all tuples up to the edge with
        the provided id.
        :param edge_id: id of the edge up to which to get the reference
        :return: list of tuples containing the data to generate the reference for an smr note, consisting of Tuples
        where the first element is a node's field content and the seconde element is the node's following edge's
        field content
        """
        return self.graph.execute("""
        {hierarchy_recursive_cte_clause}
    SELECT DISTINCT group_concat(DISTINCT {node_selection_clause}) AS node,
                    group_concat(DISTINCT {edge_selection_clause}) AS edge
    FROM ancestor a
             JOIN xmind_edges e ON a.edge_id = e.edge_id
             JOIN xmind_nodes n ON a.parent_node_id = n.node_id
    GROUP BY a.edge_id
    ORDER BY avg(a.level) DESC""".format(
            hierarchy_recursive_cte_clause=get_xmind_hierarchy_recursive_cte_clause(edge_id),
            node_selection_clause=get_xmind_content_selection_clause('n'),
            edge_selection_clause=get_xmind_content_selection_clause('e'))).fetchall()

    def get_smr_note_question_field(self, edge_id: str) -> str:
        """
        gets the content of an smr note's question field for the specified edge id
        :param edge_id: the edge id of the edge that represents the question to get the content for
        :return: the textual content for the note question field
        """
        return self.graph.execute("""
SELECT {edge_selection_clause}
FROM xmind_edges
WHERE edge_id = ?;
        """.format(edge_selection_clause=get_xmind_content_selection_clause('xmind_edges')), (edge_id,)).fetchone()[0]

    def get_smr_note_answer_fields(self, edge_id: str) -> List[str]:
        """
        gets the contents of the answer fields of the smr note belonging to the specified edge id
        :param edge_id: xmind id of the edge that belongs to the node to get the answer fields for
        :return: answer fields as a llist of strings
        """
        return [a[0] for a in self.graph.execute("""SELECT DISTINCT {node_selection_clause}
FROM smr_triples t
         JOIN xmind_nodes n ON t.child_node_id = n.node_id
WHERE edge_id = ?
ORDER BY n.order_number""".format(node_selection_clause=get_xmind_content_selection_clause('n')),
                                                 (edge_id,)).fetchall()]

    def get_smr_note_sort_data(self, edge_id: str) -> List[Tuple[int, int]]:
        """
        gets the data for generating the sort field for the notde belonging to the specified edge id
        :param edge_id: xmind id of the edge that belongs to the node to get the answer fields for
        :return: the data for generating the sort field IN a list of tuples
        """
        return self.graph.execute("""
        {hierarchy_recursive_cte_clause}
SELECT cast(count(DISTINCT n.order_number) > 1 AS INTEGER) + max(n.order_number), e.order_number
FROM ancestor a
         JOIN xmind_edges e ON a.edge_id = e.edge_id
         JOIN xmind_nodes n ON a.parent_node_id = n.node_id
GROUP BY a.edge_id
ORDER BY avg(a.level) DESC;""".format(hierarchy_recursive_cte_clause=get_xmind_hierarchy_recursive_cte_clause(
            edge_id))).fetchall()

    def attach_anki_collection(self, anki_collection: Collection):
        """
        Attaches an anki collection to the smr world for joint queries to both databases
        :param anki_collection: the anki collection to attach to the smr_world
        """
        anki_collection.close(save=True)
        self.graph.execute("ATTACH DATABASE ? as ?", (anki_collection.path, ANKI_COLLECTION_DB_NAME))

    def detach_anki_collection(self, anki_collection: Collection):
        """
        Detaches an anki collection from the smr world and reopens it
        :param anki_collection: the anki collection to detach
        """
        self.graph.commit()
        self.graph.execute("DETACH DATABASE ?", (ANKI_COLLECTION_DB_NAME,))
        anki_collection.reopen()
